/*
 * Copyright (C) 2021 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define LOG_TAG "VehiclePropertyStore"
#include <utils/Log.h>

#include "VehiclePropertyStore.h"

#include <VehicleUtils.h>
#include <android-base/format.h>

namespace android {
namespace hardware {
namespace automotive {
namespace vehicle {

using ::aidl::android::hardware::automotive::vehicle::VehicleAreaConfig;
using ::aidl::android::hardware::automotive::vehicle::VehiclePropConfig;
using ::aidl::android::hardware::automotive::vehicle::VehiclePropValue;
using ::android::base::Result;

bool VehiclePropertyStore::RecordId::operator==(const VehiclePropertyStore::RecordId& other) const {
    return area == other.area && token == other.token;
}

bool VehiclePropertyStore::RecordId::operator<(const VehiclePropertyStore::RecordId& other) const {
    return area < other.area || (area == other.area && token < other.token);
}

std::string VehiclePropertyStore::RecordId::toString() const {
    return ::fmt::format("RecordID{{.areaId={:d}, .token={:d}}}", area, token);
}

const VehiclePropertyStore::Record* VehiclePropertyStore::getRecordLocked(int32_t propId) const
        REQUIRES(mLock) {
    auto RecordIt = mRecordsByPropId.find(propId);
    return RecordIt == mRecordsByPropId.end() ? nullptr : &RecordIt->second;
}

VehiclePropertyStore::Record* VehiclePropertyStore::getRecordLocked(int32_t propId)
        REQUIRES(mLock) {
    auto RecordIt = mRecordsByPropId.find(propId);
    return RecordIt == mRecordsByPropId.end() ? nullptr : &RecordIt->second;
}

VehiclePropertyStore::RecordId VehiclePropertyStore::getRecordIdLocked(
        const VehiclePropValue& propValue, const VehiclePropertyStore::Record& record) const
        REQUIRES(mLock) {
    VehiclePropertyStore::RecordId recId{
            .area = isGlobalProp(propValue.prop) ? 0 : propValue.areaId, .token = 0};

    if (record.tokenFunction != nullptr) {
        recId.token = record.tokenFunction(propValue);
    }
    return recId;
}

Result<std::unique_ptr<VehiclePropValue>> VehiclePropertyStore::readValueLocked(
        const RecordId& recId, const Record& record) const REQUIRES(mLock) {
    auto it = record.values.find(recId);
    if (it == record.values.end()) {
        return Errorf("Record ID: {} is not found", recId.toString());
    }
    return std::make_unique<VehiclePropValue>(it->second);
}

void VehiclePropertyStore::registerProperty(const VehiclePropConfig& config,
                                            VehiclePropertyStore::TokenFunction tokenFunc) {
    std::lock_guard<std::mutex> g(mLock);

    mRecordsByPropId[config.prop] = Record{
            .propConfig = config,
            .tokenFunction = tokenFunc,
    };
}

Result<void> VehiclePropertyStore::writeValue(const VehiclePropValue& propValue) {
    std::lock_guard<std::mutex> g(mLock);

    VehiclePropertyStore::Record* record = getRecordLocked(propValue.prop);
    if (record == nullptr) {
        return Errorf("property: {:d} not registered", propValue.prop);
    }

    if (!isGlobalProp(propValue.prop) && getAreaConfig(propValue, record->propConfig) == nullptr) {
        return Errorf("no config for property: {:d} area: {:d}", propValue.prop, propValue.areaId);
    }

    VehiclePropertyStore::RecordId recId = getRecordIdLocked(propValue, *record);
    auto it = record->values.find(recId);
    if (it == record->values.end()) {
        record->values[recId] = propValue;
        return {};
    }
    VehiclePropValue* valueToUpdate = &(it->second);

    // propValue is outdated and drops it.
    if (valueToUpdate->timestamp > propValue.timestamp) {
        return Errorf("outdated timestamp: {:d}", propValue.timestamp);
    }
    // Update the propertyValue.
    // The timestamp in propertyStore should only be updated by the server side. It indicates
    // the time when the event is generated by the server.
    valueToUpdate->timestamp = propValue.timestamp;
    valueToUpdate->value = propValue.value;
    valueToUpdate->status = propValue.status;
    return {};
}

void VehiclePropertyStore::removeValue(const VehiclePropValue& propValue) {
    std::lock_guard<std::mutex> g(mLock);

    VehiclePropertyStore::Record* record = getRecordLocked(propValue.prop);
    if (record == nullptr) {
        return;
    }

    VehiclePropertyStore::RecordId recId = getRecordIdLocked(propValue, *record);
    if (auto it = record->values.find(recId); it != record->values.end()) {
        record->values.erase(it);
    }
}

void VehiclePropertyStore::removeValuesForProperty(int32_t propId) {
    std::lock_guard<std::mutex> g(mLock);

    VehiclePropertyStore::Record* record = getRecordLocked(propId);
    if (record == nullptr) {
        return;
    }

    record->values.clear();
}

std::vector<VehiclePropValue> VehiclePropertyStore::readAllValues() const {
    std::lock_guard<std::mutex> g(mLock);

    std::vector<VehiclePropValue> allValues;

    for (auto const& [_, record] : mRecordsByPropId) {
        for (auto const& [_, value] : record.values) {
            allValues.push_back(value);
        }
    }

    return allValues;
}

Result<std::vector<VehiclePropValue>> VehiclePropertyStore::readValuesForProperty(
        int32_t propId) const {
    std::lock_guard<std::mutex> g(mLock);

    std::vector<VehiclePropValue> values;

    const VehiclePropertyStore::Record* record = getRecordLocked(propId);
    if (record == nullptr) {
        return Errorf("property: {:d} not registered", propId);
    }

    for (auto const& [_, value] : record->values) {
        values.push_back(value);
    }
    return values;
}

Result<std::unique_ptr<VehiclePropValue>> VehiclePropertyStore::readValue(
        const VehiclePropValue& propValue) const {
    std::lock_guard<std::mutex> g(mLock);

    const VehiclePropertyStore::Record* record = getRecordLocked(propValue.prop);
    if (record == nullptr) {
        return Errorf("property: {:d} not registered", propValue.prop);
    }

    VehiclePropertyStore::RecordId recId = getRecordIdLocked(propValue, *record);
    return readValueLocked(recId, *record);
}

Result<std::unique_ptr<VehiclePropValue>> VehiclePropertyStore::readValue(int32_t propId,
                                                                          int32_t areaId,
                                                                          int64_t token) const {
    std::lock_guard<std::mutex> g(mLock);

    const VehiclePropertyStore::Record* record = getRecordLocked(propId);
    if (record == nullptr) {
        return Errorf("property: {:d} not registered", propId);
    }

    VehiclePropertyStore::RecordId recId{.area = isGlobalProp(propId) ? 0 : areaId, .token = token};
    return readValueLocked(recId, *record);
}

std::vector<VehiclePropConfig> VehiclePropertyStore::getAllConfigs() const {
    std::lock_guard<std::mutex> g(mLock);

    std::vector<VehiclePropConfig> configs;
    configs.reserve(mRecordsByPropId.size());
    for (auto& [_, config] : mRecordsByPropId) {
        configs.push_back(config.propConfig);
    }
    return configs;
}

Result<const VehiclePropConfig*> VehiclePropertyStore::getConfig(int32_t propId) const {
    std::lock_guard<std::mutex> g(mLock);

    const VehiclePropertyStore::Record* record = getRecordLocked(propId);
    if (record == nullptr) {
        return Errorf("property: {:d} not registered", propId);
    }

    return &record->propConfig;
}

}  // namespace vehicle
}  // namespace automotive
}  // namespace hardware
}  // namespace android
